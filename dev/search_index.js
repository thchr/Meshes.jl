var documenterSearchIndex = {"docs":
[{"location":"geometries/polytopes.html#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"geometries/polytopes.html","page":"Polytopes","title":"Polytopes","text":"Polytope\nSegment\nNgon\nChain\nPolyArea\nTetrahedron\nPyramid\nHexahedron","category":"page"},{"location":"geometries/polytopes.html#Meshes.Polytope","page":"Polytopes","title":"Meshes.Polytope","text":"Polytope{K,Dim,T}\n\nWe say that a geometry is a K-polytope when it is a collection of \"flat\" sides that constitue a K-dimensional subspace. They are called polygon and polyhedron respectively for 2D (K=2) and 3D (K=3) subspaces, embedded in a Dim-dimensional space. The parameter K is also known as the rank or parametric dimension of the polytope: https://en.wikipedia.org/wiki/Abstract_polytope.\n\nThe term polytope expresses a particular combinatorial structure. A polyhedron, for example, can be decomposed into faces. Each face can then be decomposed into edges, and edges into vertices. Some conventions act as a mapping between vertices and higher dimensional features (edges, faces, cells...), removing the need to store all features.\n\nAdditionally, the following property must hold in order for a geometry to be considered a polytope: the boundary of a (K+1)-polytope is a collection of K-polytopes, which may have (K-1)-polytopes in common. See https://en.wikipedia.org/wiki/Polytope.\n\nNotes\n\nType aliases are Polygon, Polyhedron.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Segment","page":"Polytopes","title":"Meshes.Segment","text":"Segment(p1, p2)\n\nAn oriented line segment with end points p1, p2. The segment can be called as s(t) with t between 0 and 1 to interpolate linearly between its endpoints.\n\nSee also Line.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Ngon","page":"Polytopes","title":"Meshes.Ngon","text":"Ngon(p1, p2, ..., pN)\n\nA N-gon is a polygon with N vertices p1, p2, ..., pN oriented counter-clockwise (CCW). In this case the number of vertices is fixed and known at compile time. Examples of N-gon are Triangle (N=3), Quadrangle (N=4), Pentagon (N=5), etc.\n\nNotes\n\nAlthough the number of vertices N is known at compile time, we use abstract vectors to store the list of vertices. This design allows constructing N-gon from views of global vectors without expensive memory allocations.\nType aliases are Triangle, Quadrangle, Pentagon, Hexagon, Heptagon, Octagon, Nonagon, Decagon.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Chain","page":"Polytopes","title":"Meshes.Chain","text":"Chain(p1, p2, ..., pn)\n\nA polygonal chain from a sequence of points p1, p2, ..., pn. See https://en.wikipedia.org/wiki/Polygonal_chain.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.PolyArea","page":"Polytopes","title":"Meshes.PolyArea","text":"PolyArea(outer, [inner1, inner2, ..., innerk])\n\nA polygonal area with outer chain, and optional inner chains inner1, inner2, ..., innerk.\n\nChains can be a vector of Point or a vector of tuples with coordinates for convenience.\n\nMost algorithms assume that the outer chain is oriented counter-clockwise (CCW) and that all inner chains are oriented clockwise (CW).\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Tetrahedron","page":"Polytopes","title":"Meshes.Tetrahedron","text":"Tetrahedron(p1, p2, p3, p4)\n\nA tetrahedron with points p1, p2, p3, p4.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Pyramid","page":"Polytopes","title":"Meshes.Pyramid","text":"Pyramid(p1, p2, p3, p4, p5)\n\nA pyramid with points p1, p2, p3, p4, p5.\n\n\n\n\n\n","category":"type"},{"location":"geometries/polytopes.html#Meshes.Hexahedron","page":"Polytopes","title":"Meshes.Hexahedron","text":"Hexahedron(p1, p2, ..., p8)\n\nA hexahedron with points p1, p2, ..., p8.\n\n\n\n\n\n","category":"type"},{"location":"links.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"links.html#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links.html#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links.html","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"points.html#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points.html","page":"Points","title":"Points","text":"Point\nembeddim(::Point)\ncoordtype(::Point)\ncoordinates(::Point)\n-(::Point, ::Point)\n+(::Point, ::Vec)\n-(::Point, ::Vec)\nisapprox(::Point, ::Point)","category":"page"},{"location":"points.html#Meshes.Point","page":"Points","title":"Meshes.Point","text":"Point{Dim,T}\n\nA point in Dim-dimensional space with coordinates of type T. The coordinates of the point provided upon construction are with respect to the canonical Euclidean basis.\n\nExample\n\nO = Point(0.0, 0.0) # origin of 2D Euclidean space\n\nNotes\n\nType aliases are Point1, Point2, Point3, Point1f, Point2f, Point3f\n\n\n\n\n\n","category":"type"},{"location":"points.html#Meshes.embeddim-Tuple{Point}","page":"Points","title":"Meshes.embeddim","text":"embeddim(point)\n\nReturn the number of dimensions of the space where the point is embedded.\n\n\n\n\n\nembeddim(domain)\n\nReturn the number of dimensions of the space where the domain is embedded.\n\n\n\n\n\nembeddim(geometry)\n\nReturn the number of dimensions of the space where the geometry is embedded.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Meshes.coordtype-Tuple{Point}","page":"Points","title":"Meshes.coordtype","text":"coordtype(point)\n\nReturn the machine type of each coordinate used to describe the point.\n\n\n\n\n\ncoordtype(domain)\n\nReturn the machine type of each coordinate used to describe the domain.\n\n\n\n\n\ncoordtype(geometry)\n\nReturn the machine type of each coordinate used to describe the geometry.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Meshes.coordinates-Tuple{Point}","page":"Points","title":"Meshes.coordinates","text":"coordinates(A::Point)\n\nReturn the coordinates of the point with respect to the canonical Euclidean basis.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:--Tuple{Point, Point}","page":"Points","title":"Base.:-","text":"-(A::Point, B::Point)\n\nReturn the Vec associated with the direction from point A to point B.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:+-Tuple{Point, StaticArrays.SVector{S, T} where {S, T}}","page":"Points","title":"Base.:+","text":"+(A::Point, v::Vec)\n+(v::Vec, A::Point)\n\nReturn the point at the end of the vector v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.:--Tuple{Point, StaticArrays.SVector{S, T} where {S, T}}","page":"Points","title":"Base.:-","text":"-(A::Point, v::Vec)\n-(v::Vec, A::Point)\n\nReturn the point at the end of the vector -v placed at a reference (or start) point A.\n\n\n\n\n\n","category":"method"},{"location":"points.html#Base.isapprox-Tuple{Point, Point}","page":"Points","title":"Base.isapprox","text":"isapprox(A::Point, B::Point)\n\nTells whether or not the coordinates of points A and B are approximately equal.\n\n\n\n\n\n","category":"method"},{"location":"neighborhoods.html#Neighborhoods","page":"Neighborhoods","title":"Neighborhoods","text":"","category":"section"},{"location":"neighborhoods.html","page":"Neighborhoods","title":"Neighborhoods","text":"Neighborhood\nNormBall\nEllipsoid","category":"page"},{"location":"neighborhoods.html#Meshes.Neighborhood","page":"Neighborhoods","title":"Meshes.Neighborhood","text":"Neighborhood\n\nA neighborhood is a geometry that is not attached to any specific point in the space, and is free to slide over a domain of interest.\n\n\n\n\n\n","category":"type"},{"location":"neighborhoods.html#Meshes.NormBall","page":"Neighborhoods","title":"Meshes.NormBall","text":"NormBall(radius, [metric])\n\nA norm ball with radius and metric. Default metric is Euclidean().\n\n\n\n\n\n","category":"type"},{"location":"neighborhoods.html#Meshes.Ellipsoid","page":"Neighborhoods","title":"Meshes.Ellipsoid","text":"Ellipsoid(semiaxes, angles; convention=TaitBryanExtr)\n\nAn ellipsoid with semiaxes and angles according to the rotation convention.\n\nFor 2D ellipses, there are two semiaxes and one rotation angle.\nFor 3D ellipsoids, there are three semiaxes and three rotation angles.\n\nThe list of available conventions can be found with subtypes(RotationConvention).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Partition","page":"Partition","title":"Partition","text":"","category":"section"},{"location":"algorithms/partitioning.html","page":"Partition","title":"Partition","text":"partition\nPartitionMethod\nRandomPartition\nFractionPartition\nBlockPartition\nBisectPointPartition\nBisectFractionPartition\nBallPartition\nPlanePartition\nDirectionPartition\nPredicatePartition\nSpatialPredicatePartition\nProductPartition\nHierarchicalPartition","category":"page"},{"location":"algorithms/partitioning.html#Meshes.partition","page":"Partition","title":"Meshes.partition","text":"partition(object, method)\n\nPartition object with partition method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/partitioning.html#Meshes.PartitionMethod","page":"Partition","title":"Meshes.PartitionMethod","text":"PartitionMethod\n\nA method for partitioning domain/data objects.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.RandomPartition","page":"Partition","title":"Meshes.RandomPartition","text":"RandomPartition(k, [shuffle])\n\nA method for partitioning spatial objects uniformly into k subsets of approximately equal size. Optionally shuffle the data (default to true).\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.FractionPartition","page":"Partition","title":"Meshes.FractionPartition","text":"FractionPartition(fraction, shuffle=true)\n\nA method for partitioning spatial objects according to a given fraction. Optionally shuffle elements before partitioning.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.BlockPartition","page":"Partition","title":"Meshes.BlockPartition","text":"BlockPartition(sides; neighbors=false)\nBlockPartition(side₁, side₂, ...; neighbors=false)\n\nA method for partitioning spatial objects into blocks of given sides. Optionally, compute the neighbors of a block as the metadata.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.BisectPointPartition","page":"Partition","title":"Meshes.BisectPointPartition","text":"BisectPointPartition(normal, point)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.BisectFractionPartition","page":"Partition","title":"Meshes.BisectFractionPartition","text":"BisectFractionPartition(normal, fraction=0.5, maxiter=10)\n\nA method for partitioning spatial objects into two half spaces defined by a normal direction and a fraction of points. The partition is returned within maxiter bisection iterations.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.BallPartition","page":"Partition","title":"Meshes.BallPartition","text":"BallPartition(radius; metric=Euclidean())\n\nA method for partitioning spatial objects into balls of a given radius using a metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.PlanePartition","page":"Partition","title":"Meshes.PlanePartition","text":"PlanePartition(normal; tol=1e-6)\n\nA method for partitioning spatial objects into a family of hyperplanes defined by a normal direction. Two points x and y belong to the same hyperplane when (x - y) ⋅ normal < tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.DirectionPartition","page":"Partition","title":"Meshes.DirectionPartition","text":"DirectionPartition(direction; tol=1e-6)\n\nA method for partitioning spatial objects along a given direction with bandwidth tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.PredicatePartition","page":"Partition","title":"Meshes.PredicatePartition","text":"PredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given predicate function. Two locations i and j are part of the same subset whenever predicate(i, j) == true\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.SpatialPredicatePartition","page":"Partition","title":"Meshes.SpatialPredicatePartition","text":"SpatialPredicatePartition(predicate)\n\nA method for partitioning spatial objects with a given spatial predicate function. Two coordinates x and y are part of the same subset whenever predicate(x, y) == true.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.ProductPartition","page":"Partition","title":"Meshes.ProductPartition","text":"ProductPartition(p₁, p₂)\n\nA method for partitioning spatial objects using the product of two partitioning methods p₁ and p₂.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/partitioning.html#Meshes.HierarchicalPartition","page":"Partition","title":"Meshes.HierarchicalPartition","text":"HierarchicalPartition(first, second)\n\nA partitioning method in which a first partition is applied and then a second partition is applied to each subset of the first.\n\n\n\n\n\n","category":"type"},{"location":"about/license.html","page":"License","title":"License","text":"The Meshes.jl project is licensed under the MIT license:","category":"page"},{"location":"about/license.html","page":"License","title":"License","text":"Copyright (c) 2019-2020 Júlio Hoffimann, Simon Danisch, Arsh Sharma, Anshul Singhvi,\nMartijn Visser, Daniel Schwabeneder, F Freyer, Steve Kelly, Tim Holy, Matija Čufar,\nBenoît Legat, Erik Schenetter, Jan Weidner, Mohamed Tarek, Paul Jurczak,\nZachary P. Christensen, Andrew Bylard, Yuval\n\nLicensed under the MIT license.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"algorithms/simplification.html#Simplification","page":"Simplification","title":"Simplification","text":"","category":"section"},{"location":"algorithms/simplification.html","page":"Simplification","title":"Simplification","text":"simplify\nSimplificationMethod\nDouglasPeucker","category":"page"},{"location":"algorithms/simplification.html#Meshes.simplify","page":"Simplification","title":"Meshes.simplify","text":"simplify(geometry, method)\n\nSimplify geometry with given method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/simplification.html#Meshes.SimplificationMethod","page":"Simplification","title":"Meshes.SimplificationMethod","text":"SimplificationMethod\n\nA method for simplifying geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/simplification.html#Meshes.DouglasPeucker","page":"Simplification","title":"Meshes.DouglasPeucker","text":"DouglasPeucker(ϵ)\n\nThe Douglas-Peucker algorithm for simplifying polygonal chains given a deviation tolerance ϵ.\n\nReferences\n\nDouglas, D. and Peucker, T. 1973. Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or its Caricature\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"meshes.html#Overview","page":"Meshes","title":"Overview","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Meshes can be constructed directly (e.g. CartesianGrid) or based on other constructs such as connectivity lists and topological structures (e.g. SimpleMesh).","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Mesh\nCartesianGrid\nSimpleMesh","category":"page"},{"location":"meshes.html#Meshes.Mesh","page":"Meshes","title":"Meshes.Mesh","text":"Mesh{Dim,T}\n\nA mesh embedded in a Dim-dimensional space with coordinates of type T.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.CartesianGrid","page":"Meshes","title":"Meshes.CartesianGrid","text":"CartesianGrid(dims, origin, spacing)\n\nA Cartesian grid with dimensions dims, lower left corner at origin and cell spacing spacing. The three arguments must have the same length.\n\nCartesianGrid(start, finish, dims=dims)\n\nAlternatively, construct a Cartesian grid from a start point (lower left) to a finish point (upper right).\n\nCartesianGrid(dims)\nCartesianGrid(dim1, dim2, ...)\n\nFinally, a Cartesian grid can be constructed by only passing the dimensions dims as a tuple, or by passing each dimension dim1, dim2, ... separately. In this case, the origin and spacing default to (0,0,...) and (1,1,...).\n\nExamples\n\nCreate a 3D grid with 100x100x50 locations:\n\njulia> CartesianGrid(100,100,50)\n\nCreate a 2D grid with 100x100 locations and origin at (10.,20.) units:\n\njulia> CartesianGrid((100,100),(10.,20.),(1.,1.))\n\nCreate a 1D grid from -1 to 1 with 100 locations:\n\njulia> CartesianGrid((-1.,),(1.,), dims=(100,))\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.SimpleMesh","page":"Meshes","title":"Meshes.SimpleMesh","text":"SimpleMesh(points, connec)\n\nA simple mesh with points and connectivities connec. The i-th face of the mesh is lazily built based on the connectivity list connec[i].\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Connectivities","page":"Meshes","title":"Connectivities","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"Connectivity\nconnect\nmaterialize","category":"page"},{"location":"meshes.html#Meshes.Connectivity","page":"Meshes","title":"Meshes.Connectivity","text":"Connectivity{PL,N}\n\nA connectivity list of N indices representing a Polytope of type PL. Indices are taken from a global vector of Point.\n\nConnectivity objects are constructed with the connect function.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.connect","page":"Meshes","title":"Meshes.connect","text":"connect(indices, PL)\n\nConnect a list of indices from a global vector of Point into a Polytope of type PL.\n\nExample\n\nΔ = connect((1,2,3), Triangle)\n\n\n\n\n\n","category":"function"},{"location":"meshes.html#Meshes.materialize","page":"Meshes","title":"Meshes.materialize","text":"materialize(connec, points)\n\nMaterialize a face using the connec list and a global vector of points.\n\n\n\n\n\n","category":"function"},{"location":"meshes.html#Topological-structures","page":"Meshes","title":"Topological structures","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"TopologicalStructure\nFullStructure\nHalfEdgeStructure","category":"page"},{"location":"meshes.html#Meshes.TopologicalStructure","page":"Meshes","title":"Meshes.TopologicalStructure","text":"TopologicalStructure\n\nA data structure for constructing topological relations in a Mesh.\n\nReferences\n\nFloriani, L. & Hui, A. 2007. Shape representations based on simplicial and cell complexes\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.FullStructure","page":"Meshes","title":"Meshes.FullStructure","text":"FullStructure(connectivities)\n\nA data structure that stores all connectivities of a mesh.\n\nNotes\n\nThis data structure is sometimes referred to as the \"soup of geometries\". It does not support topological relations and is therefore incompatible with algorithms that rely on neighborhood search. It is still useful for mesh visualization and IO operations.\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Meshes.HalfEdgeStructure","page":"Meshes","title":"Meshes.HalfEdgeStructure","text":"HalfEdgeStructure(halfedges, edgeonelem, edgeonvertex)\n\nA data structure for orientable 2-manifolds based on half-edges.\n\nTwo types of half-edges exist (Kettner 1999). This implementation is the most common type that splits the incident elements.\n\nA vector of halfedges together with a vector of edgeonelem and a vector of edgeonvertex can be used to retrieve topolological relations in optimal time. In this case, edgeonvertex[i] returns the index of the half-edge in halfedges with head equal to i. Similarly, edgeonelem[i] returns the index of a half-edge in halfedges that is in the elem i.\n\nSuch data structure is usually constructed from another data structure such as ElementListStructure via convert methods:\n\nhe = convert(HalfEdgeStructure, structure)\n\nSee also TopologicalStructure.\n\nReferences\n\nKettner, L. (1999). Using generic programming for designing a data structure for polyhedral surfaces\n\n\n\n\n\n","category":"type"},{"location":"meshes.html#Examples","page":"Meshes","title":"Examples","text":"","category":"section"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"using Meshes\n\n# 3D Cartesian grid\ngrid = CartesianGrid(10, 10, 10)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"using Plots\ngr(linecolor=:black, fillcolor=:gray90, size=(500,300)) # hide\n\nplot(grid)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# global vector of 2D points\npoints = Point2[(0,0),(1,0),(0,1),(1,1),(0.25,0.5),(0.75,0.5)]\n\n# connect the points into N-gon\nconnec = connect.([(1,2,6,5),(2,4,6),(4,3,5,6),(3,1,5)], Ngon)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"# 2D mesh made of N-gon elements\nmesh = SimpleMesh(points, connec)","category":"page"},{"location":"meshes.html","page":"Meshes","title":"Meshes","text":"plot(mesh)","category":"page"},{"location":"algorithms/discretization.html#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"discretize\nDiscretizationMethod","category":"page"},{"location":"algorithms/discretization.html#Meshes.discretize","page":"Discretization","title":"Meshes.discretize","text":"discretize(geometry, method)\n\nDiscretize geometry with discretization method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/discretization.html#Meshes.DiscretizationMethod","page":"Discretization","title":"Meshes.DiscretizationMethod","text":"DiscretizationMethod\n\nA method for discretizing geometries into meshes.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html#Dehn1899","page":"Discretization","title":"Dehn1899","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"Dehn1899","category":"page"},{"location":"algorithms/discretization.html#Meshes.Dehn1899","page":"Discretization","title":"Meshes.Dehn1899","text":"Dehn1899()\n\nMax Dehns' triangulation proved in 1899.\n\nThe algorithm is described in the first chapter of Devadoss & Rourke 2011, and is based on a theorem derived in 1899 by the German mathematician Max Dehn. See https://en.wikipedia.org/wiki/Twoearstheorem.\n\nBecause the algorithm relies on recursion, it is only appropriate for small polygonal areas. Currently, the implementation does not support holes.\n\nReferences\n\nDevadoss, S & Rourke, J. 2011. Discrete and computational geometry\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"using Meshes\nusing Plots\ngr(linecolor=:black, fillcolor=:gray90, size=(500,300)) # hide\n\n# polygonal area\npolyarea = PolyArea([(0.22926679, 0.47329807), (0.23094065, 0.44913536), (0.2569517, 0.38217533),\n                     (0.3072999, 0.272418), (0.34814754, 0.18421611), (0.37949452, 0.11756973),\n                     (0.4013409, 0.07247882), (0.41368666, 0.048943404), (0.42597583, 0.031655528),\n                     (0.4382084, 0.0206152), (0.45038435, 0.015822414), (0.4625037, 0.017277176),\n                     (0.47175184, 0.02439156), (0.47812873, 0.03716557), (0.4816344, 0.055599205),\n                     (0.48226887, 0.07969247), (0.48172843, 0.10446181), (0.4800131, 0.12990724),\n                     (0.47712287, 0.15602873), (0.47305775, 0.18282633), (0.47093934, 0.20558843),\n                     (0.47076762, 0.22431506), (0.47254258, 0.23900622), (0.47626427, 0.24966191),\n                     (0.47768936, 0.25845313), (0.47681788, 0.26537988), (0.4736498, 0.27044216),\n                     (0.46818516, 0.27363995), (0.4613889, 0.27232954), (0.45326096, 0.2665109),\n                     (0.44380143, 0.256184), (0.43301025, 0.24134888), (0.4246466, 0.22978415),\n                     (0.41871038, 0.22148979), (0.4152017, 0.21646582), (0.4141205, 0.21471222),\n                     (0.41227448, 0.21589448), (0.40966362, 0.22001258), (0.40628797, 0.22706655),\n                     (0.40214747, 0.23705636), (0.40200475, 0.24653101), (0.40585983, 0.25549048),\n                     (0.41371268, 0.2639348), (0.4255633, 0.2718639), (0.4378565, 0.28495985),\n                     (0.4505922, 0.30322257), (0.46377045, 0.32665208), (0.47739124, 0.35524836),\n                     (0.5046394, 0.36442512), (0.5455148, 0.35418236), (0.60001767, 0.32452005),\n                     (0.66814786, 0.27543822), (0.7186763, 0.24664374), (0.75160307, 0.23813659),\n                     (0.76692814, 0.2499168), (0.7646515, 0.28198436), (0.7769703, 0.29925033),\n                     (0.8038847, 0.3017147), (0.84539455, 0.28937748), (0.9015, 0.26223865),\n                     (0.94408435, 0.24899776), (0.9731477, 0.24965483), (0.98869, 0.26420987),\n                     (0.9907113, 0.29266283), (0.9849871, 0.31338844), (0.97151726, 0.32638666),\n                     (0.950302, 0.3316575), (0.9213412, 0.32920095), (0.8798396, 0.34078467),\n                     (0.8257972, 0.36640862), (0.7592141, 0.40607283), (0.6800901, 0.4597773),\n                     (0.6450007, 0.49104902), (0.6539457, 0.49988794), (0.7069251, 0.48629412),\n                     (0.803939, 0.45026752), (0.877913, 0.4226481), (0.9288472, 0.40343583),\n                     (0.9567415, 0.39263073), (0.961596, 0.39023277), (0.9419039, 0.40523484),\n                     (0.89766514, 0.43763688), (0.8288798, 0.48743892), (0.7355478, 0.55464095),\n                     (0.6655121, 0.60063523), (0.6187727, 0.6254217), (0.5953296, 0.62900037),\n                     (0.5951828, 0.6113712), (0.57516366, 0.60261106), (0.53527224, 0.6027198),\n                     (0.4755085, 0.6116975), (0.3958725, 0.6295441), (0.33913234, 0.6398651),\n                     (0.30528808, 0.6426605), (0.2943397, 0.6379303), (0.30628717, 0.6256744),\n                     (0.32149008, 0.6093727), (0.33994842, 0.5890249), (0.36166218, 0.5646312),\n                     (0.38663134, 0.5361916), (0.3919681, 0.520893), (0.3776725, 0.5187355),\n                     (0.34374446, 0.52971905), (0.29018405, 0.5538437), (0.25439468, 0.5678829),\n                     (0.2363764, 0.5718367), (0.23612918, 0.56570506), (0.25365302, 0.549488),\n                     (0.2733971, 0.5246488), (0.29536137, 0.49118724), (0.3195459, 0.4491035),\n                     (0.34595063, 0.39839754), (0.3647463, 0.3590396), (0.37593287, 0.33102974),\n                     (0.37951034, 0.31436795), (0.37547874, 0.30905423), (0.36070493, 0.3204269),\n                     (0.33518887, 0.348486), (0.29893062, 0.3932315), (0.25193012, 0.45466346),\n                     (0.22926679, 0.47329807)])\n\nmesh = discretize(polyarea, Dehn1899())\n\nplot(plot(polyarea), plot(mesh))","category":"page"},{"location":"algorithms/discretization.html#FIST","page":"Discretization","title":"FIST","text":"","category":"section"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"FIST","category":"page"},{"location":"algorithms/discretization.html#Meshes.FIST","page":"Discretization","title":"Meshes.FIST","text":"FIST(shuffle=true)\n\nFast Industrial-Strength Triangulation (FIST) of polygons.\n\nThis triangulation method is the method behind the famous Mapbox's Earcut library. It is based on a ear clipping algorithm adapted for complex n-gons with holes. It has O(n²) time complexity where n is the number of vertices. In practice it is very efficient due to heuristics implemented in the algorithm.\n\nThe option shuffle is used to shuffle the order in which ears are clipped. It improves the quality of the triangles, which can be very sliver otherwise.\n\nReferences\n\nHeld, M. 1998. FIST: Fast Industrial-Strength Triangulation of Polygons\nEder et al. 2018. Parallelized ear clipping for the triangulation and constrained Delaunay triangulation of polygons\n\n\n\n\n\n","category":"type"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"mesh = discretize(polyarea, FIST())\n\nplot(plot(polyarea), plot(mesh))","category":"page"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"As can be seen in the following example, FIST is also suitable for polygonal areas with holes.","category":"page"},{"location":"algorithms/discretization.html","page":"Discretization","title":"Discretization","text":"outer = [(0.18142937, 0.54681134), (0.38282228, 0.107781954), (0.43220532, 0.013640274),\n         (0.48068276, 0.019459315), (0.48322055, 0.11583236), (0.46696007, 0.2230227),\n         (0.48184678, 0.2656454), (0.45998818, 0.2784367), (0.4168235, 0.2190962),\n         (0.4124987, 0.21208182), (0.39593673, 0.2520411), (0.44333926, 0.28375763),\n         (0.4978224, 0.3981428), (0.7703431, 0.20181546), (0.7612364, 0.33008572),\n         (0.9856581, 0.2215304), (0.99374324, 0.3353423), (0.9688778, 0.38663587),\n         (0.59554976, 0.655444), (0.59496254, 0.58492756), (0.27641845, 0.656314),\n         (0.3242084, 0.6072907), (0.42408508, 0.49353212), (0.20984341, 0.59003067),\n         (0.18142937, 0.54681134)]\n\ninners = [[(0.87789994, 0.32551613), (0.5614043, 0.540334), (0.9494598, 0.39622766), (0.87789994, 0.32551613)],\n          [(0.2799388, 0.52516246), (0.38555774, 0.32233855), (0.36943135, 0.30108362), (0.2799388, 0.52516246)]]\n\npolyarea = PolyArea(outer, inners)\n\nmesh = discretize(polyarea, FIST())\n\nplot(plot(polyarea), plot(mesh))","category":"page"},{"location":"contributing/guidelines.html#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"First off, thank you for considering contributing to Meshes.jl. Below are a few suggestions to speed up the collaboration process:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"Please be polite, we are here to help and learn from each other.\nTry to explain your contribution with simple language.\nReferences to textbooks and papers are always welcome.\nFollow the coding standards in the source.","category":"page"},{"location":"contributing/guidelines.html#Reporting-issues","page":"Guidelines","title":"Reporting issues","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you are experiencing issues or have discovered a bug, please report it on GitHub. To make the resolution process easier, please include the version of Julia and Meshes.jl in your writeup. These can be found with two commands:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"julia> versioninfo()\njulia> using Pkg; Pkg.status()","category":"page"},{"location":"contributing/guidelines.html#Feature-requests","page":"Guidelines","title":"Feature requests","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have suggestions of improvement or algorithms that you would like to see implemented in Meshes.jl, please open an issue on GitHub. Suggestions as well as feature requests are very welcome.","category":"page"},{"location":"contributing/guidelines.html#Code-contribution","page":"Guidelines","title":"Code contribution","text":"","category":"section"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"If you have code that you would like to contribute to GeoStats.jl, that is awesome! Please open an issue before you create the pull request on GitHub so that we make sure your idea is aligned with our goals for the project.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"After your idea is discussed and revised by maintainers, please get the development version of the project by typing the following in the package manager:","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] activate @dev","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will create a fresh environment called @dev where you can play with the project components without compromising your normal user environment.","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"] dev Meshes","category":"page"},{"location":"contributing/guidelines.html","page":"Guidelines","title":"Guidelines","text":"This will clone all the project components in your ~/.julia folder so that you can modify it and submit a pull request on GitHub later. Don't hesitate to ask questions. We are looking forward to your contributions.","category":"page"},{"location":"algorithms/neighborsearch.html#Neighbor-search","page":"Neighbor search","title":"Neighbor search","text":"","category":"section"},{"location":"algorithms/neighborsearch.html","page":"Neighbor search","title":"Neighbor search","text":"search\nNeighborSearchMethod\nBallSearch\nKNearestSearch\nKBallSearch\nBoundedSearch","category":"page"},{"location":"algorithms/neighborsearch.html#Meshes.search","page":"Neighbor search","title":"Meshes.search","text":"search(pₒ, method, mask=nothing)\n\nReturn neighbors of point pₒ using method. Optionally, specify a mask for all indices of the domain.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/neighborsearch.html#Meshes.NeighborSearchMethod","page":"Neighbor search","title":"Meshes.NeighborSearchMethod","text":"NeighborSearchMethod\n\nA method for searching neighbors given a reference point.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.BallSearch","page":"Neighbor search","title":"Meshes.BallSearch","text":"BallSearch(domain, ball)\n\nA method for searching neighbors in domain inside ball.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.KNearestSearch","page":"Neighbor search","title":"Meshes.KNearestSearch","text":"KNearestSearch(domain, k; metric=Euclidean())\n\nA method for searching k nearest neighbors in domain according to metric.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.KBallSearch","page":"Neighbor search","title":"Meshes.KBallSearch","text":"KBallSearch(domain, k, ball)\n\nA method that searches k nearest neighbors and then filters these neighbors using a norm ball.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/neighborsearch.html#Meshes.BoundedSearch","page":"Neighbor search","title":"Meshes.BoundedSearch","text":"BoundedSearch(method, nmax)\n\nA method for searching at most nmax neighbors using method.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/intersection.html#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"Intersections are implemented for various geometries such as Segment, Line, and Box:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"using Meshes # hide\ns1 = Segment((0.0,0.0), (1.0,0.0))\ns2 = Segment((0.5,0.0), (2.0,0.0))\n\ns1 ∩ s2","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"The algorithm first identifies the type of intersection using intersecttype:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"I = intersecttype(s1, s2)","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"and then retrieves the actual value using get:","category":"page"},{"location":"algorithms/intersection.html","page":"Intersection","title":"Intersection","text":"get(I)","category":"page"},{"location":"geometries/primitives.html#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"geometries/primitives.html","page":"Primitives","title":"Primitives","text":"Primitive\nLine\nRay\nPlane\nBox\nCylinder\nBall\nSphere","category":"page"},{"location":"geometries/primitives.html#Meshes.Primitive","page":"Primitives","title":"Meshes.Primitive","text":"Primitive{Dim,T}\n\nWe say that a geometry is a primitive when it can be expressed as a single entity with no parts (a.k.a. atomic). For example, a sphere is a primitive described in terms of a mathematical expression involving a metric and a radius. See https://en.wikipedia.org/wiki/Geometric_primitive.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Line","page":"Primitives","title":"Meshes.Line","text":"Line(a, b)\n\nA line passing through points a and b.\n\nSee also Segment.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Ray","page":"Primitives","title":"Meshes.Ray","text":"Ray(p, v)\n\nA ray originating at point p, pointed in direction v. It can be called as r(t) with t > 0 to cast it at p + t * v.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Plane","page":"Primitives","title":"Meshes.Plane","text":"Plane(p₀, v, w)\n\nA plane coincident with point p₀, defined by non-parallel vectors v and w. It can be called as p(s, t) with numeric parameters s and t to cast it at p₀ + s*v + t*w.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Box","page":"Primitives","title":"Meshes.Box","text":"Box(min, max)\n\nAn axis-aligned box with min and max corners. See https://en.wikipedia.org/wiki/Hyperrectangle.\n\nExample\n\nBox(Point(0,0,0), Point(1,1,1)) # unit cube\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Cylinder","page":"Primitives","title":"Meshes.Cylinder","text":"Cylinder(start, finish, radius)\n\nA right circular cylinder with start and finish points, and radius of revolution. See https://en.wikipedia.org/wiki/Cylinder. \n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Ball","page":"Primitives","title":"Meshes.Ball","text":"Ball(center, radius)\n\nA ball with center and radius.\n\n\n\n\n\n","category":"type"},{"location":"geometries/primitives.html#Meshes.Sphere","page":"Primitives","title":"Meshes.Sphere","text":"Sphere(center, radius)\n\nA sphere with center and radius.\n\n\n\n\n\n","category":"type"},{"location":"vectors.html#Vectors","page":"Vectors","title":"Vectors","text":"","category":"section"},{"location":"vectors.html","page":"Vectors","title":"Vectors","text":"Vec","category":"page"},{"location":"vectors.html#Meshes.Vec","page":"Vectors","title":"Meshes.Vec","text":"Vec{Dim,T}\n\nA vector in Dim-dimensional space with coordinates of type T representing a direction with magnitude. A vector can be obtained by subtracting two Point objects:\n\nExample\n\nA = Point(0.0, 0.0)\nB = Point(1.0, 0.0)\nv = B - A\n\nNotes\n\nA Vec is a SVector from StaticArrays.jl\nType aliases are Vec1, Vec2, Vec3, Vec1f, Vec2f, Vec3f\n\n\n\n\n\n","category":"type"},{"location":"algorithms/boundingbox.html#Bounding-box","page":"Bounding box","title":"Bounding box","text":"","category":"section"},{"location":"algorithms/boundingbox.html","page":"Bounding box","title":"Bounding box","text":"boundingbox","category":"page"},{"location":"algorithms/boundingbox.html#Meshes.boundingbox","page":"Bounding box","title":"Meshes.boundingbox","text":"boundingbox(geometry)\n\nAxis-aligned bounding box of the geometry.\n\n\n\n\n\nboundingbox(domain)\n\nAxis-aligned bounding box of the domain.\n\n\n\n\n\n","category":"function"},{"location":"angles.html#Angles","page":"Angles","title":"Angles","text":"","category":"section"},{"location":"angles.html","page":"Angles","title":"Angles","text":"∠","category":"page"},{"location":"angles.html#Meshes.∠","page":"Angles","title":"Meshes.∠","text":"∠(A, B, C)\n\nAngle ∠ABC between rays BA and BC. See https://en.wikipedia.org/wiki/Angle.\n\nUses the two-argument form of atan. See https://en.wikipedia.org/wiki/Atan2.\n\nExample\n\n∠(Point(1,0), Point(0,0), Point(0,1)) == π/2\n\n\n\n\n\n","category":"function"},{"location":"contributing/devguide.html#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"contributing/devguide.html#Benchmarking","page":"Developer guide","title":"Benchmarking","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"We use PkgBenchmark.jl to conduct benchmarks, coupled with BenchmarkCI.jl to automate benchmark runs with GitHub Actions on certain PRs. Currently, PRs will not run benchmarks by default. Only PRs with the label run benchmark will trigger benchmarks on push, adding a comment with the benchmark results.","category":"page"},{"location":"contributing/devguide.html#Running-benchmarks-locally","page":"Developer guide","title":"Running benchmarks locally","text":"","category":"section"},{"location":"contributing/devguide.html#With-PkgBenchmark","page":"Developer guide","title":"With PkgBenchmark","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"To locally run benchmarks, you can use PkgBenchmark.jl with the following code:","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"# make sure PkgBenchmark and BenchmarkTools\n# are installed globally before running it\nusing Meshes, PkgBenchmark\nbenchmarkpkg(Meshes)","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"It will include benchmark/benchmarks.jl and look for a BenchmarkGroup variable named SUITE, that it will run for you with a nice printing.","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"The full list of options is detailed in the PkgBenchmark documentation.","category":"page"},{"location":"contributing/devguide.html#Manually","page":"Developer guide","title":"Manually","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Sometimes you may prefer to run the suite manually, especially during interactive development. All you have to do is include the benchmark/benchmarks.jl file, and run the BenchmarkGroup suite:","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"include(\"benchmark/benchmarks.jl\")\nrun(SUITE)","category":"page"},{"location":"contributing/devguide.html#Limitations","page":"Developer guide","title":"Limitations","text":"","category":"section"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Note that because GitHub Actions may use different runners between benchmarks, you are likely to see fluctuations and performance changes that may not always be relevant. This makes it somewhat unreliable for tracking regressions.","category":"page"},{"location":"contributing/devguide.html","page":"Developer guide","title":"Developer guide","text":"Benchmark results can be very useful for validation, for example when optimizing or modifying existing features, but you are encouraged to benchmark important changes locally.","category":"page"},{"location":"index.html#Meshes.jl","page":"Home","title":"Meshes.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Computational geometry and meshing algorithms in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status) (Image: Stable Documentation) (Image: Latest Documentation) (Image: License File)","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Meshes.jl provides efficient implementations of concepts from computational geometry and finite element analysis. It promotes rigorous mathematical definitions of spatial discretizations (a.k.a. meshes) that are adequate for describing general manifolds embedded in R^n, including surfaces described with spherical coordinates, and geometries described with multiple coordinate reference systems. Our ambitious goal is to provide all the features of the CGAL project in pure Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Unlike other existing efforts in the Julia ecosystem, this project is being carefully designed to facilitate the use of meshes across different scientific domains. We follow a strict set of good software engineering practices, and are quite pedantic in our test suite to make sure that all our implementations are free of bugs in both single and double floating point precision. Additionally, we guarantee type stability.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The design of this project was motivated by various issues encountered with past attempts to represent geometry, which have been originally designed for visualization purposes (e.g. GeometryTypes.jl, GeometryBasics.jl) or specifically for finite element analysis (e.g. JuAFEM.jl, MeshCore.jl). We hope to provide a smoother experience with mesh representations that are adequate for finite finite element analysis, advanced geospatial modeling and visualization, not just one domain.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Get the latest stable release with Julia's package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add Meshes","category":"page"},{"location":"index.html#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Although we didn't have time to document the functionality of the package properly, we still would like to illustrate some important features. For more information on available functionality, please consult the Reference guide and the suite of tests in the package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Meshes\nusing Plots","category":"page"},{"location":"index.html#Points-and-vectors","page":"Home","title":"Points and vectors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A Point is defined by its coordinates in a global reference system. The type of the coordinates is determined automatically based on the specified literals, or is forced to a specific type using helper constructors (e.g. Point2, Point3, Point2f, Point3f).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A vector Vec follows the same pattern. It can be constructed with the generic Vec constructor or with the variants Vec2 and Vec3 for double precision and Vec2f and Vec3f for single precision.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A = Point(0, 0) # point with integer coordinates\nB = Point(1, 0) # another point in 2D space\nC = Point(0.0, 1.0) # double precision\nD = Point2(0, 1) # double precision from Int literal\nE = Point(1, 2, 3) # a point in 3D space\nF = Point3(1, 2, 3) # another point now with double precision\nG = Point(1f0, 2f0, 3f0) # single precision\nH = Point3f(1, 2, 3) # single precision from Int literal\n\nfor P in (A,B,C,D,E,F,G,H)\n  println(\"Coordinate type: \", coordtype(P))\n  println(\"Embedding dimension: \", embeddim(P))\nend","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Points can be subtracted to produce a vector:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"B - A","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"They can't be added, but their coordinates can:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"coordinates(G) + coordinates(H)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can add a point to a vector though, and get a new point:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"G + Vec3f(1,1,1)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And finally, we can create points at random with:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ps = rand(Point2, 10)","category":"page"},{"location":"index.html#Primitives","page":"Home","title":"Primitives","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Primitive geometries such as Box, Ball, Sphere, Cylinder are those geometries that can be efficiently represented in a computer without discretization. We can construct such geometries using clean syntax:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"b = Box((0,0), (1,1))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"s = Sphere((0,0), 1)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The parameters of these primitive geometries can be queried easily:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"extrema(b)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"centroid(s), radius(s)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As well as their measure (e.g. area, volume) and other geometric properties:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"measure(b)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can sample random points on primitives using different methods:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"vs = sample(s, RegularSampling(10)) # 10 points over the sphere","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And collect the generator with:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"collect(vs)","category":"page"},{"location":"index.html#Polytopes","page":"Home","title":"Polytopes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Polytopes are geometries with \"flat\" sides. They generalize polygons and polyhedra. Most commonly used polytopes are already defined in the project, including Segment, Ngon (e.g. Triangle, Quadrangle), Tetrahedron, Pyramid and Hexahedron.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"t = Triangle((0,0), (1,0), (0,1))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Some of these geometries have additional functionality like the measure (or area):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"measure(t) == area(t) == 1/2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or the ability to know whether or not a point is inside:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"p = Point(0.5, 0.0)\n\np ∈ t","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For line segments, for example, we have robust intersection algorithms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"s1 = Segment((0.0,0.0), (1.0,0.0))\ns2 = Segment((0.5,0.0), (2.0,0.0))\n\ns1 ∩ s2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Polytopes are widely used in GIS software under names such as \"LineString\" and \"Polygon\". We provide robust implementations of these concepts, which are formally known as polygonal Chain and PolyArea.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can compute the orientation of a chain as clockwise or counter-clockwise, can open and close the chain, create bridges between the various inner rings with the outer ring, and other useful functionality:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"p = PolyArea(Point2[(0,0), (2,0), (2,2), (1,3), (0,2), (0,0)])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The orientation of the above polygonal area is counter-clockwise (CCW):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"orientation(p)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can get the outer polygonal chain, and reverse it:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"c = chains(p)[1]\n\nreverse(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A closed chain (a.k.a. ring) has circular vertices:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"v = vertices(c)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This means that we can index the vertices with indices that go beyond the range 1:nvertices(c). This is very useful for writing algorithms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"v[1:10]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can also compute angles of any given chain, no matter if it is open or closed:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"angles(c) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The sign of these angles is a function of the orientation:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"angles(reverse(c)) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In case of closed chains, we can compute inner angles as well:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"innerangles(c) * 180 / pi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"And there is a lot more functionality available like for instance determining whether or not a polygonal area or chain is simple:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"issimple(p)","category":"page"},{"location":"index.html#Meshes","page":"Home","title":"Meshes","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Efficient (lazy) mesh representations are provided, including CartesianGrid and SimpleMesh:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"g = CartesianGrid(100, 100)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"No memory is allocated:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@allocated CartesianGrid(10000, 10000, 10000)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"but we can still loop over the elements, which are quadrangles in 2D:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"collect(elements(g))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We can construct a general unstructured mesh with a global vector of points and a collection of Connectivity that store the indices to the global vector of points:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"points = Point2[(0,0), (1,0), (0,1), (1,1), (0.25,0.5), (0.75,0.5)]\ntris  = connect.([(1,5,3),(4,6,2)], Triangle)\nquads = connect.([(1,2,6,5),(4,3,5,6)], Quadrangle)\nmesh = SimpleMesh(points, [tris; quads])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The actual geometries of the elements are materialized in a lazy fashion like with the Cartesian grid:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"collect(elements(mesh))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and many geometries and meshes can be directly plotted with Plots.jl:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"plot(mesh, linecolor=:black, fillcolor=:gray90)","category":"page"},{"location":"algorithms/sampling.html#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"algorithms/sampling.html","page":"Sampling","title":"Sampling","text":"sample\nSamplingMethod\nRegularSampling\nUniformSampling\nWeightedSampling\nBallSampling","category":"page"},{"location":"algorithms/sampling.html#StatsBase.sample","page":"Sampling","title":"StatsBase.sample","text":"sample(geometry, method)\n\nSample elements from geometry with method.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/sampling.html#Meshes.SamplingMethod","page":"Sampling","title":"Meshes.SamplingMethod","text":"SamplingMethod\n\nA method for sampling from geometries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.RegularSampling","page":"Sampling","title":"Meshes.RegularSampling","text":"RegularSampling(n1, n2, ..., np)\n\nSample geometry regularly using n1 points along the first parametric dimension, n2 points along the second parametric dimension, ..., np poitns along the last parametric dimension.\n\nExample\n\nSample sphere regularly with 360 longitudes and 180 latitudes:\n\nsample(Sphere((0,0,0), 1), RegularSampling(360, 180))\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.UniformSampling","page":"Sampling","title":"Meshes.UniformSampling","text":"UniformSampling(size, replace=false)\n\nSample elements uniformly from a given domain/data. Produce a sample of given size with or without replacement depending on the replace option.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.WeightedSampling","page":"Sampling","title":"Meshes.WeightedSampling","text":"WeightedSampling(size, [weights]; replace=false)\n\nSample elements from a given domain/data using weights. Produce a sample of given size with or without replacement depending on the replace option. By default weights are uniform.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/sampling.html#Meshes.BallSampling","page":"Sampling","title":"Meshes.BallSampling","text":"BallSampling(radius; [options])\n\nA method for sampling isolated elements from a given domain/data according to a norm-ball of given radius.\n\nOptions\n\nmetric  - Metric for the ball (default to Euclidean())\nmaxsize - Maximum size of the resulting sample (default to none)\n\n\n\n\n\n","category":"type"}]
}
